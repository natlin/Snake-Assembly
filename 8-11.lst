LINE ADDR CONTENTS SOURCE LINE
  1.              ;Authors Nathan Lin, Matthew Yap
  2.              
  3.              	.EQU TDR_CNTL, $020
  4.              	.EQU TDR_STAT, $020
  5.              	.EQU TDR_LEN, $021
  6.              	.EQU TDR_ADDR, $022
  7.              
  8.              	.EQU READ_BITS, $10
  9.              	.EQU MOUNTED_BIT, $20
 10.              	.EQU EOT_BIT, $08
 11.              
 12.              	.EQU CRT_CNTL, $316
 13.              	.EQU CRT_DATA, $317
 14.              
 15.              	.EQU NEXT_LINE_VALUE, $0D
 16.              
 17.  000 020E00  	LDS# $E00
 18.              
 19.  001 702020  MAIN:	INB TDR_STAT	; CHECK FOR TAPE DRIVE READY
 20.  002 4B2028  	JGE STOP
 21.  003 000029  	LDA# BUFFER	; LOAD TRANSFER ADDRESS
 22.  004 732022  	OUTW TDR_ADDR
 23.  005 00001E  NEXT_REC:	LDA# B_SIZE	; LOAD TRANSFER LENGTH
 24.  006 712021  	OUTB TDR_LEN
 25.  007 000010  	LDA# READ_BITS	; INITIATE READ
 26.  008 712020  	OUTB TDR_CNTL
 27.  009 702020  POLL:	INB TDR_STAT	; WAIT FOR OPERATION COMPLETE
 28.  00A 4A200E  	JLT COMPLETE
 29.  00B 300020  	AND# MOUNTED_BIT	; CHECK THAT TAPE STILL MOUNTED
 30.  00C 482028  	JEQ STOP	; IF NOT, AN ERROR HAS OCCURRED
 31.  00D 402009  	JMP POLL
 32.  00E 300008  COMPLETE:	AND# EOT_BIT	; CHECK FOR END OF TAPE
 33.  00F 492028  	JNE STOP
 34.  010 702021  	INB TDR_LEN	; GET TRANSFER LENGTH
 35.  011 482020  	JEQ NEW_LINE	; IF ZERO, SKIP DATA OUTPUT
 36.  012 042033  	STA COUNT	; INITIALIZE COUNTER COUNT
 37.  013 010000  	LDX# 0
 38.              ;COPY_CHAR:	LDC BUFFER	; GET CHARACTER
 39.              ;	OUTB CRT_DATA	; COPY TO SCREEN
 40.              ;	AOC COUNT	; LOOP BACK IF NOT DONE
 41.              ;	JLT COPY_CHAR
 42.              
 43.              ;	.EQU CHAR, 2	;FORMAL PARAMETER
 44.              	.EQU PRT_STAT, $010
 45.              	.EQU PRT_DATA, $011
 46.              	.EQU ON_LINE_BIT, $020
 47.              
 48.              ;PRINT:	BGN# 0	; INIT. CALL
 49.  014 702010  LOOP:	INB PRT_STAT	; GET PRINTER STATUS
 50.  015 4A201A  	JLT READY	; IF PRINTER IS READY, PRINT CHAR.
 51.  016 300020  	AND# ON_LINE_BIT
 52.  017 492014  	JNE LOOP
 53.  018 000001  OFF_LINE:	LDA# 1	; ACC = 1 TO INDICATE FAILURE
 54.  019 402020  	JMP NEW_LINE
 55.  01A 502029  READY:	LDC BUFFER	; GET CHARACTER AND
 56.  01B 712011  	OUTB PRT_DATA	; PRINT IT
 57.  01C 602033  	AOC COUNT
 58.  01D 4A2014  	JLT LOOP
 59.  01E 000000  	LDA# 0	; ACC = 0 TO INDICATE SUCCESS
 60.  01F 402020  	JMP NEW_LINE
 61.              ;DONE:	FIN# 0	; CLOSE CALL
 62.              ;	RTN
 63.              
 64.              NEW_LINE:	
 65.  020 702010  LOOP2:	INB PRT_STAT
 66.  021 4A2024  	JLT NEW_LINE2
 67.  022 300020  	AND# ON_LINE_BIT
 68.  023 492020  	JNE LOOP2
 69.  024 00000D  NEW_LINE2:	LDA# NEXT_LINE_VALUE	; MOVE CURSOR TO NEXT LINE
 70.  025 712011  	OUTB PRT_DATA
 71.  026 402005  	JMP NEXT_REC
 72.  027 4820E0  	jeq $E0
 73.  028 FFFFFF  STOP:	HLT
 74.              
 75.              	.EQU B_SIZE, 30	; MAX CHARACTERS PER RECORD
 76.  029 FFFFFFFFFFFFFFFF  BUFFER:	.BLKW (B_SIZE+2)/3	; BUFFER LENGTH IS ROUNDED UP
 77.  033 FFFFFFFFFFFFFFFF  COUNT:	.BLKW 1

                     SYMBOL TABLE CONTENTS

000029 = BUFFER          00001E = B_SIZE          00000E = COMPLETE        
000033 = COUNT           000316 = CRT_CNTL        000317 = CRT_DATA        
000008 = EOT_BIT         000014 = LOOP            000020 = LOOP2           
000001 = MAIN            000020 = MOUNTED_BIT     000020 = NEW_LINE        
000024 = NEW_LINE2       00000D = NEXT_LINE_VALUE 000005 = NEXT_REC        
000018 = OFF_LINE        000020 = ON_LINE_BIT     000009 = POLL            
000011 = PRT_DATA        000010 = PRT_STAT        00001A = READY           
000010 = READ_BITS       000028 = STOP            000022 = TDR_ADDR        
000020 = TDR_CNTL        000021 = TDR_LEN         000020 = TDR_STAT        
